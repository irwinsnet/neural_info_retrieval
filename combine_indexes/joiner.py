"""Class for creating indexes from two sets of term weights.

This module works with JSONL data files generated by DeepCT or HDCT.
The files have the format:
```
{"id": "D2322065", "contents": "water water water ... grow"}\n
{"id": "D1055090", "contents": "alberta alberta ... origin"}\n
...
```
The files are suitable for indexing with Lucerne. There is one document
per line.

Stacy Irwin, 22 July 2021
"""

import argparse
import collections
import datetime
import json
import os
import os.path

from tqdm import tqdm

import util.indexer

class IndexJoiner():
    """Combines two document indexes to create a new index.

    Initialization:
    idx_joiner = IndexJoiner([idx0_path, idx1_path],
                             join_data_file='join_data.json')

    idx1_path and idx2_path are paths to two different document indexes
    generated by the HDCT model. Each path can contain several JSONL
    files, where each line is a JSON dictionary:
    {'id'; 'contents': 'word0 word0 word1 word2 word2 word2 ... wordN'}
    The JSONL files are formatted such that they can be read by the
    Lucene index generator. Term weights are encoded per the number of
    repetitions of each word. If a word has a term weight of 10, for example,
    the word will be repeated 10 times, separated by spaces.

    The document indexes need not list documents in the same order.
    If a document appears in one index but not the other index, the
    document will generally be included in the final index, depending
    on the specific join method.

    Initializing IndexJoiner does NOT join the indexes. Joining indexes
    requires two additional method calls.

    1. IndexJoiner.set_join_type(join_type, join_args)
        * `join_type` is a string that matches the name of one of the
        join methods. The currently available join methods are:
          * join_docs_sum_weights
          * join_docs_avg_weights_qry_discount
          * join_docs_max_weights_qry_discount
        * `join_args` is a dictionary containing the custom arguments
        needed for the join. The key is the name of the argument.
        For example, join_docs_avg_weights_qry_discount requires one
        additional argument, 'qry_discount'. For this join type, the
        join_args argument should be `{'qry_discount': F.F} where F.F is
        a floating point number.
    2. IndexJoiner.join_indexes(output_path)
        * output_path is a path to an empty folder. The joined index
        files will be written to this folder. The folder must already
        exist before calling `join_indexes`.

    When joining indexes, IndexJoiner iterates through every entry in
    index 0 and retrieves the corresponding record from index 1 using
    the index datastructure contained in util.indexer.IndexedFile.
    The records for the two indexes need not be in the same order.
    Also, if one index is larger than the other, recommend that index
    be procssed as index 0.

    Initializing an IndexJoiner object results in the creation of
    sevaral data files.
    1. a *.pickled-index file is created for each input file. The
    *.pickled-index files contain indexes to every document ID in all
    input files, allowing fast random access to document term weights
    given a document ID. These files will be created from scratch the
    first time IndexJoiner is initialzied on a given set of input files,
    but for subsequent runs, the indexes need only be read from disk,
    which is much faster. The *.pickled-index files are generated by
    the util.indexer.IndexedFile class.
    2. When first initialized, IndexJoiner identifies all mismatched
    document IDs. Mismatched document IDs are ID values that appear in
    only one of the input indexes, but not both. For large indexes, this
    step is time consuming. The mismatched document IDs are written to
    the file specified by the constructor's `join_data_file` argument.
    If the file alredy exists, the mismatched document IDs are read from
    the file instead of being recalculated, which saves considerable
    time. Be careful not use an old join data file calculated from
    different document indexes.
    """

    def __init__(self,
                 idx_paths,
                 join_data_file='join_data.json'):
        """Initializes IndexJoiner object and pre-processes inputs.

        Args:
            idx_paths: List containing two strings. Strings are paths
                to folders containing the indexes to be joined.
            join_data_file: Name of file in which mismatched data will
                be saved, or from which mismatched data will be read.
                Optional. Defaults to 'join_data.json'.
        """
        assert len(idx_paths) == 2
        print('Preparing to join document indexes.')
        print('Files for index 0 stored in:', idx_paths[0])
        print('Files for index 1 stored in:' , idx_paths[1])
        print('Start Time:', datetime.datetime.now(), '\n')

        # Get paths to all json files for both indices
        self.idx_paths = idx_paths
        self.idx_files = [
            [os.path.join(idx_path, fname) for fname in os.listdir(idx_path)
             if fname[-5:] == '.json']
            for idx_path in idx_paths]
        for idx_file_lst in self.idx_files:
            idx_file_lst.sort()       

        # Open join_data file if it exists
        print('Processing mismatched documents, i.e., checking for')
        print('    documents that exist in only one index.')
        self.data_file_name = join_data_file
        if os.path.isfile(join_data_file):
            print('Reading mismatched documents data from ', join_data_file)
            with open(join_data_file) as dfile:
                self.join_data = json.load(dfile)
        else:
            self.join_data = {}
            self.join_data['idx0_only_ids'] = self._get_mismatched_docs(0)
            self.join_data['idx1_only_ids'] = self._get_mismatched_docs(1)
            with open(join_data_file, 'wt') as jdfile:
                json.dump(self.join_data, jdfile)
        print('Number of documents that exist only in index 0:',
              len(self.join_data['idx0_only_ids']))
        print('Number of documents that exist only in index 1:',
              len(self.join_data['idx1_only_ids']))
        print()
        
        # Create or open file indexes
        print('Initializing File Indexes')
        self.file_indexes = self._get_file_indexes()
        print()

        # Attributes for specific join types
        self.join_args = None
        self.join_docs_method = None

        print('Join preparation is complete.')
        print('Completion Time:', datetime.datetime.now())

        # Join Type Help Message
        if __name__ != '__main__':
            print('The next step is specifying a index join type.')
            print('The available join types are:')
            for att in dir(self):
                if att[:9] == 'join_docs' and att != 'join_docs_method':
                    print('  *', att)
            print(
                """Example:
    idx_jnr = joiner.IndexJoiner([idx0_path, idx1_path])
    idx_joinr.set_join_type('join_docs_avg_weights_qry_discount',
                            {'qry_discount': 0.8})""")
            print("See join methods's docstring for required join_args.")

    def set_join_type(self, join_type, join_args):
        """Specifies the type of join and join arguments.

        Call this method after initializing the IndexJoiner object, but
        before running IndexJoiner.join_indexes().

        Args:
            join_type: Name of the IndexJoiner method that will be used
                to join the two input indexes. Must start with
                'join_docs'.
            join_args: Python dictionary containing additional arguments
                that are required for the join. Format:
                `{'arg_name': arg_value}
        """
        print('Setting join type to', join_type)
        print(join_args)
        if join_type[:9] == 'join_docs' and hasattr(self, join_type.lower()):
            self.join_docs_method = getattr(self, join_type)
            self.join_args = join_args
        else:
            raise ValueError('Incorrect join type.') 
        print('The next step is running join_indexes(output_path) method.')

    def join_indexes(self, output_path):
        """Joins the two input indexes.

        Do not call this method until after a join type has been
        specified with IndexJoiner.set_join_type().

        An separate output file will be created for every index file in
        index 0.

        Args:
            output_path: The file location where the joined index files
                will be written.
        """
        print('Joining Indexes using {}'.format(self.join_docs_method))
        print('Join arguments:', self.join_args)
        print('Iterating through documents in Index 0.')
        print('Start Time:', datetime.datetime.now())
        for idx, ifile in enumerate(self.idx_files[0]):
            ifilename = os.path.split(ifile)[1]
            file_len = len(self.file_indexes[0][idx])
            with    open(ifile) as idxfile, \
                    open(os.path.join(output_path, ifilename), 'wt') as ofile:
                for line in tqdm(idxfile, ifilename, file_len):
                    doc1_data = json.loads(line)
                    doc1_id = doc1_data['id']
                    doc2_txt = self.get_doc(1, doc1_id)
                    try: 
                        doc2_data = json.loads(doc2_txt)
                    except json.JSONDecodeError:
                        doc2_data = None
                    joined_doc_data = self.join_docs_method(doc1_data,
                                                            doc2_data)
                    ofile.write(json.dumps(joined_doc_data) + '\n')
        self._add_missing_docs(output_path)
        print('Index join complete.')
        print('Stop Time:', datetime.datetime.now())

    def get_doc(self, idx, doc_id):
        """Retrieves a document.

        Args:
            idx: Specifies from which index the document should be
                retrieved. Either 0 or 1.
            doc_id: String. The document ID of the desired document.

        Returns: A line of text, formatted as JSON, containing the 
        desired document. Or returns an empty string if the document
        does not exist in the specified index.
        """
        self._check_idx(idx)
        for doc_idx in self.file_indexes[idx]:
            try:
                doc = doc_idx[doc_id]
            except KeyError:
                continue
            else:
                return doc
        return ''

    def _get_mismatched_docs(self, idx):
        """Get list of documents that appear in only one input index.

        Args:
            idx: Integer, either 0 or 1. If 0, returns list of document
                IDs that appear in index 0 but not in index 1. If 1,
                returns list of document IDs that appear in index 1, but
                not in index 0.
        """
        self._check_idx(idx)
        other_idx = (idx + 1) % 2
        print('Identifying doc_ids in index',
                '{} that are not in index {}'.format(idx, other_idx))
        ids = self._get_ids(idx)
        ids_other = self._get_ids(other_idx)
        return list(ids.difference(ids_other))

    def _get_file_indexes(self):
        """Creates an IndexedFile objects for each input file.

        Returns:
        A nested list structured as so:
        [
            [idx0_file0, idx0_file1, ..., idx0_file_m]
            [idx1_file0, idx1_file1, ..., idx1_file_n]
        ]
        m and n are the number of files in input index 0 and input index
        1 respectively.
        """
        return [[util.indexer.IndexedFile(fpath, 'id', line_idx=True)
                 for fpath in flist]
                for flist in self.idx_files]

    def _get_ids(self, idx):
        """Gets a list of all document ID values for a given index.

        Args:
            idx: 0 or 1

        Returns all document IDs in the input index specified by the idx
        argument.
        """
        self._check_idx(idx)
        print('Reading IDs from index', idx)
        id_set = set()
        for file in self.idx_files[idx]:
            with open(file) as jfile:
                for line in tqdm(jfile, file):
                    data = json.loads(line)
                    id_set.add(data['id'])
        return id_set

    def _check_idx(self, idx):
        """ Raises error if index value is not 0 or 1.
        """
        assert idx in list(range(len(self.idx_paths)))

    def _add_missing_docs(self, output_path):
        """Adds mismatched documents to joined index.

        Index entries for mismatched documents will be saved in a file
        named docs_mismatched.json.

        Args:
            ouput_path: filesystem locatin where combined index entries
                will be saved.
        """
        print('Iterating through documents in index 1 that are not in index 0.')
        with open(os.path.join(output_path, 'docs_mismatched.json'), 'wt') as ofile:
            for doc_id in tqdm(self.join_data['idx1_only_ids']):
                doc_txt = self.get_doc(1, doc_id)
                try:
                    doc_data = json.loads(doc_txt)
                except json.JSONDecodeError:
                    continue
                processed_doc_data = self.join_docs_method(None, doc_data)
                ofile.write(json.dumps(processed_doc_data) + '\n')

    def _get_weights(self, doc_data):
        """Extracts term weights from index entry.

        Args:
            doc_data: A dictionary with two keys, 'id', and 'contents'.
                'id' contains the document ID and 'contents' contains
                a text string with term separated by spaces. Each term
                is repeated w times, where w is the term's weight.

        Returns:
            A Python dictionary with two keys: 'id' and 'weights'. The
            'id' value is the document ID and the 'weights' value is
            another Python dictionary with a key for every term and
            term weights for the values.
        """
        return {'id': doc_data['id'],
                'weights': collections.Counter(doc_data['contents'].split())}

    def _compare_terms(self, doc0_weights, doc1_weights):
        """Compares the terms in two different index records.

        Args:
            doc0_weights, doc1_weights: Python dictionary containing
            term weights (see docstring for ._get_weights() for more
            info).
        """
        assert doc0_weights['id'] == doc1_weights['id']
        doc0_terms = frozenset(doc0_weights['weights'].keys())
        doc1_terms = frozenset(doc1_weights['weights'].keys())
        doc0_only_terms = doc0_terms - doc1_terms
        doc1_only_terms = doc1_terms - doc0_terms
        common_terms = doc0_terms & doc1_terms
        return {'id': doc0_weights['id'],
                'doc0_terms': doc0_terms,
                'doc1_terms': doc1_terms,
                'doc0_only_terms': doc0_only_terms,
                'doc1_only_terms': doc1_only_terms,
                'common_terms': common_terms}

    def _expand_weights(self, doc_weights):
        """Converts document weights to an index record.

        Args:
            doc_weights: Python dictionary containing
            term weights (see docstring for ._get_weights() for more
            info).

        Returns:
            A document index record, consisting of a Python dictionary
            with 'id' and 'contents' keys. The contents consists of a
            single string with each separated by spaces and repeated
            according to it's weight.
        """
        terms_array = [[term] * weight
                       for term, weight in doc_weights['weights'].items()]
        terms_list = [term for term_list in terms_array for term in term_list]
        contents = ' '.join(terms_list)
        return {'id': doc_weights['id'], 'contents': contents}

    def join_docs_sum_weights(self, doc0_data, doc1_data):
        """Join method that sums weights from both input indexes.

        This join type does not require any join_args.

        Args:
            doc0_data, doc1_data: Index records for a single doucment,
            both of which have 'id' and 'contents' keys. Raises an
            AssertionError if the document IDs don't match.

        Returns:
            An index record, with terms combined as such:
              * Term appears in only one input index: The term weight
              from the index in which it appears, unalterned.
              * Term appears in both input indexes: The sum of the two
              term weights.
        """
        if doc1_data is None:
            doc1_data = {'id': doc0_data['id'], 'contents': ''}
        assert doc0_data['id'] == doc1_data['id']
        return {'id': doc0_data['id'],
                'contents': doc0_data['contents'] + ' ' + doc1_data['contents']}

    def join_docs_avg_weights_qry_discount(self, doc0_data, doc1_data):
        """Join method that averages weights from both indexes.

        If a term appears in only one index, it's as if that term has
        a zero weight.

        This join type requires one join_arg: {'qry_discount': F}
        F is a floating point value. The term weight from index 1
        will be multiplied by this value before subsequent processing.

        For example, if F == 0.5, all index 1 term weights will be
        multiplied by 0.5 before they are averaged with index 0 wieghts,
        or before they are written to the ouput record.

        Args:
            doc0_data, doc1_data: Index records for a single doucment,
            both of which have 'id' and 'contents' keys. Raises an
            AssertionError if the document IDs don't match.

        Returns:
            An index record, with terms combined as such:
              * Term appears in only one input index: The term weight
              from the index in which it appears, unalterned.
              * Term appears in both input indexes: The sum of the two
              term weights.
        """
        # Check for missing document
        if doc0_data is None:
            doc0_data = {'id': doc1_data['id'], 'contents': ''}
        if doc1_data is None:
            doc1_data = {'id': doc0_data['id'], 'contents': ''}
        assert doc0_data['id'] == doc1_data['id']

        # Calculate and compare term weights
        doc0_weights = self._get_weights(doc0_data)
        doc1_weights = self._get_weights(doc1_data)
        term_data = self._compare_terms(doc0_weights, doc1_weights)

        # Calculate new term weights
        joined_weights = {'id': doc0_data['id'], 'weights': {}}
        qry_discount = self.join_args['qry_discount']
        for term in term_data['common_terms']:
            weight = round((doc0_weights['weights'][term] +
                           qry_discount * doc1_weights['weights'][term]) / 2)
            joined_weights['weights'][term] = int(max(weight, 1))
        for term in term_data['doc0_only_terms']:
            joined_weights['weights'][term] = doc0_weights['weights'][term]
        for term in term_data['doc1_only_terms']:
            weight = round(qry_discount * doc1_weights['weights'][term])
            joined_weights['weights'][term] = int(max(weight, 1))
        return self._expand_weights(joined_weights)

    def join_docs_max_weights_qry_discount(self, doc0_data, doc1_data):
        """Join method that takes the maximum weight.
      
        If a term appears in only one index, it's as if that term has
        a zero weight in the index in which it's missing.

        This join type requires one join_arg: {'qry_discount': F}
        F is a floating point value. The term weight from index 1
        will be multiplied by this value before subsequent processing.

        For example, if F == 0.5, all index 1 term weights will be
        multiplied by 0.5 before the max is taken or before they are
        written to the ouput record.

        Args:
            doc0_data, doc1_data: Index records for a single doucment,
            both of which have 'id' and 'contents' keys. Raises an
            AssertionError if the document IDs don't match.

        Returns:
            An index record, with terms combined as such:
                * Term appears in only one input index: The term weight
                from the index in which it appears, unalterned.
                * Term appears in both input indexes: The sum of the two
                term weights.
        """
        # Check for missing input
        if doc0_data is None:
            doc0_data = {'id': doc1_data['id'], 'contents': ''}
        if doc1_data is None:
            doc1_data = {'id': doc0_data['id'], 'contents': ''}
        assert doc0_data['id'] == doc1_data['id']

        # Calculate and compare term weights
        doc0_weights = self._get_weights(doc0_data)
        doc1_weights = self._get_weights(doc1_data)
        term_data = self._compare_terms(doc0_weights, doc1_weights)

        # Calculate new term weights.
        joined_weights = {'id': doc0_data['id'], 'weights': {}}
        qry_discount = self.join_args['qry_discount']
        for term in term_data['common_terms']:
            weight = round(max(doc0_weights['weights'][term], 
                           qry_discount * doc1_weights['weights'][term]))
            joined_weights['weights'][term] = int(max(weight, 1))
        for term in term_data['doc0_only_terms']:
            joined_weights['weights'][term] = doc0_weights['weights'][term]
        for term in term_data['doc1_only_terms']:
            weight = round(qry_discount * doc1_weights['weights'][term])
            joined_weights['weights'][term] = int(max(weight, 1))
        return self._expand_weights(joined_weights)

       

